




File: chill.info, Node: Top

Short Sample
************

This is a short sample Texinfo file.

* Menu:

* First Chapter::       Introduction
* Index::               Complete index.



File: chill.info, Node: First Chapter

Introduction
************

CHiLL is a source-to-source translator for composing high level loop
transformations to improve the performance of nested loop calculations
written in C, C++ or FORTRAN. CHiLL's operations are driven by a user
supplied script file which specifies the location of the original
source file, the function and loops to transform in that file and the
transformations to create a new transformed source file. A version of
CHiLL called CUDA-CHiLL can generate source code for both host
functions and device functions which can be compiled with the NVIDIA
CUDA Compiler Driver and executed on NVIDIA GPUs.


Intended Audience
=================
This manual is intended for C/C++ or FORTRAN programmers wishing to
optimize loop based calculations. The user should have sufficient
knowledge of the underlying hardware on which the code should execute
to generate an optimization strategy.


Getting CHiLL
=============
CHiLL is available in source form from
https://github.com/CtopCsUtahEdu. CHiLL relies on the ROSE compiler
from Lawrence Livermore National Laboratory that must be installed
before CHiLL. To install CHiLL simply execute the following commands
within the root of the source directory.

     ./configure --with-interface=python
     make

If you have problems or issues with installation or have comments,
questions or suggestions for this document, please send mail to
<bobw@cs.utah.edu>.


Invoking CHiLL
==============
Assume the code below is in a file named `mm.c'. This program written
in C implements matrix multiplication as a direct translation of an
optimized FORTRAN program where all of the loops are ordered such that
memory accesses to the arrays a, b and c are all in column
order. Since C and C++ store arrays in row major order there is an
opportunity for better cache utilization if the arrays are accessed as
rows and not columns.

     void mm(float **A, float **B, float **C, 
             int ambn, int an, int bm) {
       int i, j, n;
       for(i = 0; i < an; i++)
         for(j = 0; j < bm; j++) {
           C[i][j] = 0.0f;
           for(n = 0; n < ambn; n++)
             C[i][j] += A[i][n] * B[n][j];
         }
     }

Permuting the order of the loops from j, k, i to i, k, j results in a
more cache centric algorithm where all array accesses are in row major
order as shown below.

     void mm(float **A, float **B, float **C,
     	int ambn, int an, int bm) {
       int i, j, k;
       for (n = 0; n <= ambn - 1; n += 1) 
         for (j = 0; j <= bm - 1; j += 1) 
           if (n <= 0) 
             for (i = 0; i <= an - 1; i += 1) {
               C[i][j] = 0.0f;
               C[i][j] += (A[i][n] * B[n][j]);
             }
           else 
             for (i = 0; i <= an - 1; i += 1) 
               C[i][j] += (A[i][n] * B[n][j]);
     }

The interchanges of the outer and inner most loops can be done in
CHiLL with this simple Python script.

     from chill import *
     source('mm.c')
     procedure('mm')
     loop(0)
     known(['ambn > 0', 'an > 0', 'bm > 0'])
     permute([3,2,1])
     print_code()


The first line of the script `from chill import *' loads the CHiLL
interface into the python interpreter. The commands `source' and
`procedure' identify the source file and the procedure to modify. The
`loop' command specifies the loop nest to be transformed. The `known'
command specifies constraints on parameters that are known and the
transformation `permute([3,2,1])' exchanges the inner and outer most
loops.  Assuming for this example that that the script above is in the
file `mm.py', the command `chill mm.script' would produce the
transformed code in the file `rose_mm.c'. (1) (*Note First
Chapter-Footnotes::)


File: chill.info  Node: First Chapter-Footnotes, Up: First Chapter

(1) Change this, should have output(filename) command



File: chill.info, Node: Second Chapter

Background
**********

CHiLL allows a programmer to optimize loop nests by permuting the
sequence in which statements in the original code are execute to
exploit a hardware advantage such as reordering memory access to be
more cache efficient or reordering the execution of statements to
utilize multiple threads.

Not all statements can be reordered. If a dependence exists between
two statements it creates a constraint on the ability to schedule the
relative execution of the statements. To guarantee that the original
code and transformed code produce the same results all transformations
must insure that the two dependent statements execute in the original
order.


Dependences
===========

Before CHiLL applies a user specified transformations to the loop
structure it first insures that the transformed code will produce the
same results as the original code. It does this by determining all
dependences between statements in the original program and then
requiring that any and all transformations that are applied preserve
the dependences between the statements in the original code.

To effectively use CHiLL, it is important to understand the types of
dependences that can exist and the effects that transformations have
on those dependences. There are two general categories of dependences,
data dependences and control dependences.

A "control dependence" exist when one statement is executed
conditionally on the result of another. For example, in the statements
below `S1' cannot be executed before `S0' and thus `S1' has a control
dependence on `S0'.
       S0     if (x != 0)
       S1       a /= x;

A "data dependence" exists between statements `S0' and `S1' (meaning
`S1' depends on statement `S0') if and only if there is a plausible
run-time execution path from `S0' to `S1', both statements access the
same memory location and at least one of them stores to it. There are
three types of data dependences:

A "true dependence" exists when `S0' writes to a location that is
later read by `S1'.

       S0     x = ...
       S1     ... = x

An "antidependence" exists when `S0' reads from a location that is
later written to by `S1'.
       S0     ... = x
       S1     x = ...

An "output dependence" exists when `S0' writes to a location that is
later written to by `S1'.
       S0     x = ...
       S1     x = ...

In the parlance of hardware design, a true dependence is known as a @abbr{RAW, read after write} hazard, an antidependence is a @abbr{WAR, write after read} hazard and an output dependence is a @abbr{WAW, write after write} hazard. These dependences are fairly intuitively and are used instinctively by every programmer to determine the correct order of statements in sequential code. However, when loops and arrays are involved these same data dependences arise in more subtle ways.

@section Dependences with loops and arrays

@cindex loop-independent dependence
@cindex loop-carried dependence
It is useful to categorize data dependences in loops as two types. Consider loop that contains two statements, @code{S0} and @code{S1} within it. If both @code{S0} and @code{S1} reference the same memory location within the same iteration as they do in this case, then the dependence is @dfn{loop-independent}. If statement @code{S0} and @code{S1} reference the same memory location in different iterations, then the dependence is created by the loop and it is said to be @dfn{loop-carried}.@refill

Consider the example below which has two loop-independent dependences between the statements independen of the iteration of the loop. Statement @code{S1} has a true dependence on @code{S0} as @code{S1} must read the value @code{b[i]} @emph{after} @code{S0} writes it and @code{S0} has an antidependence in @code{S1} as @code{S0} must write @code{a[i]} @emph{before} @code{S1} reads it.@refill
@smallexample
       for (i = 0; i < n; i++) @{
  S0     a[i] = b[i];
  S1     b[i] = a[i] + 1;
       @}
@end smallexample

Contrast this to the loop below which has two loop-carried dependences and two loop-independent dependences.@refill

@smallexample
       for (i = 0; i < n; i++) @{
  S0     a[i + 1] = b[i];
  S1     b[i + 1] = a[i];
  S2     c[i] = a[i] + b[i];
       @}
@end smallexample

In every iteration other than the first, @code{S1} reads an element of @code{a[]} that was written to by @code{S0} in the previous iteration and thus there is dependence from @code{S0} to @code{S1}. Because @code{S0} appears before @code{S1} in the loop, it is a loop-carried forward true dependence.@refill

Likewise, for every iteration other than the first, @code{S0} uses a value of @code{b[]} that was written by @code{S1} in the previous iteration and thus there is also a dependence from @code{S1} to @code{S0} but because @code{S1} appears after @code{S0} in the loop, it is a loop-carried backward true dependence.@refill

However, @code{S2} reads a value of @code{a[]} that was written by @code{S0} and a value of @code{b[]} that was written by @code{S1} in the same iteration and thus there is both a loop-independent true dependence of @code{S2} on @code{S0} and a loop-independent true dependence of @code{S2} on @code{S1}.@refill

@section Iteration Vectors

Iteration vectors are used to specify the execution order of statements within the loop nest to ensure that dependences between statements are maintained. We define an iteration vector in a nest of @math{n} loops as @math{@strong{i} = @{i_1, i_2, ..., i_n@}} where @math{i_k} is the value of the index of the loop at nesting @math{k}.@refill

Iteration vectors are ordered. Interation vector @math{@strong{i}} @i{preceeds} iteration @math{@strong{j}}, denoted @math{@strong{i} < @strong{j}}, if and only if @math{@strong{i}[1:n-1] < @strong{j}[1:n-1]} or @math{@strong{i}[1:n-1] = @strong{j}[1:n-1]} and @math{i_n < j_n}.@refill

The above scheme captures the progression of all of the loop indicies in the nest. To capture the lexical ordering of statements within loops we introduce an auxilary loop before each loop level and an auxillary loop as the last dimension. This allows a uniform method to both track the progression of the loop levels as well as schedule the statements within a loop as shown below.@refill

@page
Consider the following loop nest below. There are three loop levels to track the three indicies i, j and k and four auxillary loop levels to track the relative execution of the statements within the loops.@refill
@smallexample
S0
for (i @dots{}) @{
  S1
  S2
  for (j @dots{}) @{
    S3
    S4
    for (k @dots{}) @{
      S5
      S6
    @}
  @}
@}
@end smallexample

The iteration vectors which would describe the execution order of the statements above are shown below.@refill
@sp 1

@smallexample 
S0: [0, 0, 0, 0, 0, 0, 0]
S1: [1, i, 0, 0, 0, 0, 0]
S2: [1, i, 1, 0, 0, 0, 0]
S3: [1, i, 0, j, 0, 0, 0]
S4  [1, i, 0, j, 1, 0, 0]
S5: [1, i, 0, j, 0, k, 0]
S6: [1, i, 0, j, 0, k, 1]
@end smallexample
@sp 1

If were were told that the current point of execution of the above loop nest was described by the iteration vector [1, 3, 0, 2, 0, 8, 1] we would know that statement S6 was executing with the indexes of the loops being i = 3, j = 2 and k = 8.@refill

@section Distance and Direction Vectors

@section Iteration Spaces

@section Legalily of Transformations

@node Third Chapter
@chapter The CHiLL Scripting Language

@section Loop and Statement Identification

The first two statements in this and every CHiLL script identify the source file and the procedure to modify. Only one source file and one procedure can be modified in any single script.@refill

Individual loops within a loop nest are identified by level that they are nested and the statement that they surround. The outer most loop of a nest is always loop level 1. Thus in the previous example, the transformation @samp{permute([3,2,1])} exchanged the inner and outer most loops.@refill

It is very important to realize that every transformation has the capability to insert or reorder the loops and thus the identification of a specific loop will change after a transformation. In figure 1 the j, k and i loops that were respectively at levels 1, 2 and 3 before the permutation are now at levels 3, 2 and 1 after the transformation. Any subsequent transformation must use these new loop levels to identify the individual loops.@refill

Conceptually CHiLL treats the statements in a loop nest as one of three types: loops, conditionals and everything else. When we refer to "a statement" in CHiLL, we are referring to a block of one or more program statements which have a single uninterrupted execution path through them.@refill

Consider the pseudo code below.@refill

@smallexample
for (i ...) @{
  S0
  for (j ...) @{
    S1
    for (k ...)
      S2
  @}
  for (j ...)
    S3
@}  
@end smallexample


The loop level alone insufficient to uniquely determine a specific loop within a nest unless a statement enclosed by the loop is also provided. Statements are initially numbered in the order they appear from top to bottom in the nest starting with zero. Transformations may also insert or reorder the statements in the nest and thus the identification of a specific statement can change after a transformation as well.@refill

The @command{print_code} command by default displays C-like pseudo code of the nest showing the loops, indices and statements. Statements consist of the largest block of code that does not contain a loop or conditional statement. The statement in the pseudo-code appears as a function indexed by the loop indices as if it were a call to the block of code.
Adding print statements around the permute transformation in figure 3 would produce the following output
The arguments in the call to s0 before and after the transformation show that the first and last loops indices have been exchanged in the statement block.@refill

@page
@section Commands

@c @def
pefn {Transform} @code{tile} {} (int @var{stmt}, int @var{level}, int @var{tile_size}, int @var{outer_level} = 1, TileMethod @var{method} = StridedTile, int @var{alignment_offset} = 1, @* int @var{alignment_multiple} = 1) 

@c Source
@cindex source command
@deftypefn {Command} @code{source}(string @var{filename})
The @code{source} command specifies the filename of the original code to be transformed. For example @samp{source("mm.c")}. There can only be one @code{source} command in a script and it must preceed the @code{loop} command.@refill
@end deftypefn

@c Procedure
@cindex procedure command
@deftypefn {Command} @code{procedure}(string @var{name})
The @code{procedure} command specifies the procedure name in the file to transform. For example @samp{procedure("mm")}. There can only be one procedure modified in a given script.@refill
@end deftypefn

@c Loop
@cindex loop command
@deftypefn {Command} @code{loop}(int @var{level})
@deftypefnx {Command} @code{loop}(int @var{start}, int @var{end})
The @command{loop} command specifies the loop nest to be transformed by specifying the top level loop of the nest. Top level loops are those loops at procedure scope and are numbered starting from zero. The first form of the command selects a nest contained in a single top level loop. The second form takes a range of top level loops and treats them as a single unified nest.@refill

The @code{loop} command can be issued multiple times in a script to select and modify different top level loops within the same file.@refill
@end deftypefn

@c The print command takes one of five forms:
@deftypefn {Command} {} @code{print_code}()
The @code{print code} commands display C-like pseudo code of the nest showing the loops, indices and statements. Statements in the pseudo-code appears as a function indexed by the loop indices as if it were a call to the block of code.@refill

For example, the command @code{print_code} applied to the loop@refill
@sp 1
@smallexample
for(i = 0; i < an; i++)
  for(j = 0; j < bm; j++) @{
    C[i][j] = 0.0f;
    for(n = 0; n < ambn; n++)
      C[i][j] += A[i][n] * B[n][j];
  @}
@end smallexample

produces the results@refill
@smallexample
for(t2 = 0; t2 <= an-1; t2++) @{
  for(t4 = 0; t4 <= bm-1; t4++) @{
    s0(t2,t4,0);
    s1(t2,t4,0);
    for(t6 = 1; t6 <= ambn-1; t6++) @{
      s1(t2,t4,t6);
    @}
  @}
@}
@end smallexample

Notice that the first iteration of statement s1 was peeled from the innermost loop and the iteration space of that loop was modified to start at 1 and not 0.@refill
@end deftypefn

@page
@cindex print_dep command
@deftypefn {Command} {} @code{print_dep}()
The @code{print_dep} command displays the dependences between all statements in the current nest. For example, the command @code{print_dep()} applied to the loop@refill
@sp 1
@smallexample
for(i = 0; i < an; i++)
  for(j = 0; j < bm; j++) @{
    C[i][j] = 0.0f;
    for(n = 0; n < ambn; n++)
      C[i][j] += A[i][n] * B[n][j];
  @}
@end smallexample
gives the following results.@refill

@smallexample
s0->s1: C:true(0, 0, +) C:true(0, 0, 0) C:output(0, 0, +) C:output(0, 0, 0)
s1->s1: C:anti(0, 0, +) C:output(0, 0, +)
@end smallexample
@sp 1
It shows two statements and the dependences between them. There are four dependences between statements s0 and s1 and two dependences between s1 and itself.@refill
@sp 1
Given a nest with @math{n} loops each individual dependence has the form:@refill
@indentedblock
@var{var}:@var{type}(@math{d_1}, @math{d_2}, @dots{}, @math{d_n})
@end indentedblock
where @var{var} is the variable name that is creating the dependence, @var{type} is the type of dependence which is one of @i{_quasi}, @i{true}, @i{anti}, @i{output}, @i{input}, @i{control} or @i{unknown}.@refill

The value of @math{d_i} indicates the distance of the dependence between the source and sink carried by loop @i{i} and is one of the following symbols below where @math{n}, @math{n_l} and @math{n_u} represent integer values in the iteration space of the loop.@refill
@multitable @columnfractions .1 .2 .2 .2 .3
@headitem @tab Symbol @tab Lower Bound @tab Upper Bound
@item @tab @math{n} @tab @math{n} @tab @math{n}
@item @tab @math{n_l{\sim}n_u} @tab @math{n_l} @tab @math{n_u}
@item @tab @math{*} @tab @math{-\infty} @tab @math{+\infty}
@item @tab @math{-} @tab @math{-\infty} @tab @math{-1}
@item @tab @math{n-} @tab @math{-\infty} @tab @math{n}
@item @tab @math{+} @tab @math{1} @tab @math{+\infty}
@item @tab @math{n+} @tab @math{n} @tab @math{+\infty}
@end multitable
@end deftypefn

@cindex print_space command
@deftypefn {Command} {} @code{print_space}()
The @code{print_space} command displays the iteration space for each statement in the current nest. For example, the command @code{print_space()} applied to the loop@refill
@sp 1
@smallexample
for(i = 0; i < an; i++)
  for(j = 0; j < bm; j++) @{
    C[i][j] = 0.0f;
    for(n = 0; n < ambn; n++)
      C[i][j] += A[i][n] * B[n][j];
  @}
@end smallexample
gives the following results.@refill

@smallexample
s0: @{ Sym=[bm,an,ambn] [t1,t2,t3,t4,t5,t6,t7] : t1 = 0 && t3 = 0 && t5 = 0 && @*     t7 = 0 && t6 = 0 && 0 <= t2 < an && 0 <= t4 < bm && 1 <= ambn @}
s1: @{ Sym=[ambn,bm,an] [t1,t2,t3,t4,t5,t6,t7] : t1 = 0 && t3 = 0 && t5 = 0 && @*     t7 = 0 && 0 <= t2 < an && 0 <= t6 < ambn && 0 <= t4 < bm @}
@end smallexample

The notation for an iteration space is that of a set of indicies [t1, t2, @dots{} ,tn] where n is the two times number loops in the nest plus one and the definition of which includes symbols designated in the Sym=[ @dots{} ] construction followed by a colon and the defining relationships between the symbols and iteration values.@refill
@sp 1
The odd elements of the iteration space represent phantom loops for establishing the order of multiple statements within a loop and the even elements of the iteration space represent the values of the actual indexes of the loops in the nest.@refill
@end deftypefn

@cindex print_structure command
@deftypefn {Command} {} @code{print_structure}()
The @code{print structure} command displays the structure of each statement.@refill
@smallexample
s1: 0(dim:0) 0(dim:1) 0(dim:2) 0
@end smallexample
@end deftypefn

@cindex exit command
@c The exit command has the form:
@deftypefn {Command} {} @code{exit}()
The @code{exit} command exists the script.@refill
@end deftypefn

@cindex known command
@c The known command has the form:
@deftypefn {Command} {} @code{known}(vector @var{cond})
The @code{known} command adds a condition as an expression.@refill
@end deftypefn

@unnumberedsubsec Remove dependency
@c The remove dependency has the form:
@deftypefn {Command} @code{remove_dep} {} (int @var{stmt1}, int @var{stmt2})
The @code{remove_dep} removes a dependence between two statements in the loop nest.@refill
@end deftypefn

@cindex pragma command
@c The pragma command has the form:
@deftypefn {Command} @code{pragma} {} (int @var{stmt}, int @var{level}, string @var{text})
The @code{pragma} does what?@refill
@end deftypefn

@page
@section Transformations
@c --------------------------------- Original -----------------------------
@unnumberedsubsec Original
@deftypefn {Transform} @code{original} ()
The @code{original} transformation initializes the loop structure without permuting it.@refill
@end deftypefn
@multitable @columnfractions .50 .50 
@b{Python Script}
@smallformat
@cartouche
@verbatim
from chill import *
source('mm.c')
procedure('mm')
loop(0)
known(['ambn > 4', 'an > 0', 'bm > 0'])
peel(1,3,4)
print_code()
original()
print_code()
@end verbatim
@end cartouche
@end smallformat
@tab @b{Original code}
@smallformat
@cartouche
@verbatim
void mm(float **A, float **B, float **C, 
        int ambn, int an, int bm) {
  int i, j, n;
  for(i = 0; i < an; i++) {
    for(j = 0; j < bm; j++) {
      C[i][j] = 0.0f;
      for(n = 0; n < ambn; n++) {
        C[i][j] += A[i][n] * B[n][j];
      }
    }
  }
}
@end verbatim
@end cartouche
@end smallformat
@end multitable

@multitable @columnfractions .50 .50
@b{Output on stdout}
@smallformat
@cartouche
@verbatim
for(t2 = 0; t2 <= an-1; t2++) {
  for(t4 = 0; t4 <= bm-1; t4++) {
    s0(t2,t4,0);
    s1(t2,t4,0);
    for(t6 = 1; t6 <= ambn-1; t6++) {
      s1(t2,t4,t6);
    }
  }
}
@end verbatim
@end cartouche
@end smallformat
@tab @b{Transformed code}
@smallformat
@cartouche
@verbatim
void mm(float **A, float **B, float **C,
        int ambn, int an, int bm) {
  int i, j, n;
  for (i = 0; i <= an - 1; i += 1) 
    for (j = 0; j <= bm - 1; j += 1) {
      C[i][j] = 0.0f;
      C[i][j] += (A[i][0] * B[0][j]);
      for (n = 1; n <= ambn - 1; n += 1) 
        C[i][j] += (A[i][n] * B[n][j]);
    }
}
@end verbatim
@end cartouche
@end smallformat
@end multitable

@c --------------------------------- Permute -----------------------------
@page
@unnumberedsubsec Permute
The @code{permute} transformation interchanges the loops of a loop nest.@refill
@deftypefn {Transform} @code{permute} {} (int @var{stmt} = 0, int @var{level} = 0, Vector @var{p})
The loop nest to permute is specified by @var{stmt} and @var{level}. The loops in the next are permuted acording to the vector @var{p}.@refill
@end deftypefn
@multitable @columnfractions .50 .50 
@b{Python Script}
@smallformat
@cartouche
@verbatim
from chill import *
source('mm.c')
procedure('mm')
loop(0)
known(['ambn > 0', 'an > 0', 'bm > 0'])
permute([3,1,2])
print_code()
@end verbatim
@end cartouche
@end smallformat
@tab @b{Original code}
@smallformat
@cartouche
@verbatim
void mm(float **A, float **B, float **C, 
        int ambn, int an, int bm) {
  int i, j, n;
  for(i = 0; i < an; i++)
    for(j = 0; j < bm; j++) {
      C[i][j] = 0.0f;
      for(n = 0; n < ambn; n++)
        C[i][j] += A[i][n] * B[n][j];
    }
}
@end verbatim
@end cartouche
@end smallformat
@end multitable

@multitable @columnfractions .50 .50
@b{Output on stdout}
@smallformat
@cartouche
@verbatim
for(t2 = 0; t2 <= ambn-1; t2++) {
  for(t4 = 0; t4 <= an-1; t4++) {
    if (t2 <= 0) {
      for(t6 = 0; t6 <= bm-1; t6++) {
        s0(t4,t6,t2);
        s1(t4,t6,t2);
      }
    }
    else {
      for(t6 = 0; t6 <= bm-1; t6++) {
        s1(t4,t6,t2);
      }
    }
  }
}
@end verbatim
@end cartouche
@end smallformat
@tab @b{Transformed code}
@smallformat
@cartouche
@verbatim
void mm(float **A, float **B, float **C,
        int ambn, int an, int bm) {
  int i, j, n;
  for (n = 0; n <= ambn - 1; n += 1) 
    for (i = 0; i <= an - 1; i += 1) 
      if (n <= 0) 
        for (j = 0; j <= bm - 1; j += 1) {
          C[i][j] = 0.0f;
          C[i][j] += (A[i][n] * B[n][j]);
        }
      else 
        for (j = 0; j <= bm - 1; j += 1) 
          C[i][j] += (A[i][n] * B[n][j]);
}
@end verbatim
@end cartouche
@end smallformat
@end multitable

@c --------------------------------- Tile -----------------------------
@page
@unnumberedsubsec Tile
The @code{tile} transformation allows a loop dimension to be segregated into tiles, the execution of which are scheduled by a control loop placed outside the tiled loop. Statements and loops inside the control loop will be executed a tile at a time along the tiled dimension.
@deftypefn {Transform} @code{tile} {} (int @var{stmt}, int @var{level}, int @var{tile_size}, int @var{outer_level} = 1, TileMethod @var{method} = StridedTile, int @var{alignment_offset} = 1, @* int @var{alignment_multiple} = 1) 
@b{Arguments}
The loop nest to tile is specified by @var{stmt} and @var{level}. The @var{tile_size} specifies the tile size, a value of 0 indicates no tiling, a value of 1 is similar to loop interchange. The @var{outer_loop} @dots{}
@end deftypefn
@multitable @columnfractions .50 .50 
@b{Python Script}
@smallformat
@cartouche
@verbatim
from chill import *
source('mm.c')
procedure('mm')
loop(0)
known(['ambn > 0', 'an > 0', 'bm > 0'])
tile(0,2,4)
print_code()
@end verbatim
@end cartouche
@end smallformat
@tab @b{Original code}
@smallformat
@cartouche
@verbatim
void mm(float **A, float **B, float **C, 
        int ambn, int an, int bm) {
  int i, j, n;

  for(i = 0; i < an; i++)
    for(j = 0; j < bm; j++) {
      C[i][j] = 0.0f;
      for(n = 0; n < ambn; n++)
        C[i][j] += A[i][n] * B[n][j];
    }
}
@end verbatim
@end cartouche
@end smallformat
@end multitable

@multitable @columnfractions .50 .50
@b{Output on stdout}
@smallformat
@cartouche
@verbatim
chill test_tile.py
for(t2 = 0; t2 <= bm-1; t2 += 4) {
  for(t4 = 0; t4 <= an-1; t4++) {
    for(t6 = t2; t6 <= min(t2+3,bm-1); t6++) {
      s0(t4,t6,0);
      s1(t4,t6,0);
      for(t8 = 1; t8 <= ambn-1; t8++) {
        s1(t4,t6,t8);
      }
    }
  }
}
@end verbatim
@end cartouche
@end smallformat
@tab @b{Transformed code}
@smallformat
@cartouche
@verbatim
#define __rose_lt(x,y) ((x)<(y)?(x):(y))
void mm(float **A, float **B, float **C,
        int ambn, int an, int bm) {
  int i, j, n, jj;
  for (jj = 0; jj <= bm - 1; jj += 4) 
    for (i = 0; i <= an - 1; i += 1) 
      for (j=jj; j<=__rose_lt(bm-1,jj+3); 
           j+=1) {
        C[i][j] = 0.0f;
        C[i][j] += (A[i][0] * B[0][j]);
        for (n = 1; n <= ambn - 1; n += 1) 
            C[i][j] += (A[i][n] * B[n][j]);
      }
}
@end verbatim
@end cartouche
@end smallformat
@end multitable

@c tile           stmt#
@c                loop level to tile
@c                tile size
@c                  = 0 means no tiling
@c                  = 1 similar to loop interchange
@c                  = d tiling with tile/block size d
@c                tile controlling loop level (default = 1, i.e. outermost loop)
@c                tile controlling loop iteration method
@c                tile boundary alignment offset (default = 0, >= 0)
@c                tile boundary alignment multiple (default = 1, >= 1)
@c align the starting point of the very first tile to be the closest designated  multiples right below (original_lb - offset)

@c --------------------------------- Unroll -----------------------------
@page
@unnumberedsubsec Unroll
@c Unroll
@deftypefn {Transform} @code{unroll} {} (int @var{stmt}, int @var{level}, int @var{unroll_amount}, int @var{cleanup_split_level})
The @code{unroll} transformation allows a loop dimension to be unrolled.
@b{Arguments}

@c The unroll command has four forms:
@c unroll (expr, number, expr)
@c unroll (expr, number, expr, expr)
@c unroll_extra (expr, number, expr)
@c unroll_extra (expr, number, expr, expr)
@c The unroll command @dots{}
@c unroll         stmt#
@c                loop level to unroll
@c                unroll amount
@c                  = 0 means fully unroll the loop if the number of iterations
@c                      can be determined statically, otherwise no unrolling
@c                  = 1 means no unrolling
@c                  = d means loop body unrolled d times and then fused together
@c                      if it is legal
@c                cleanup code splitted at loop level
@c                  (default to unroll loop level)
@c unroll_extra   stmt#
@c                loop level to unroll
@c                unroll_amount
@c                  same as unroll except the cleanup loop is fully unrolled
@c                  whenever possible
@c                cleanup code splitted at loop level
@c                  (default to unroll loop level)

@end deftypefn
@multitable @columnfractions .50 .50 
@b{Python Script}
@smallformat
@cartouche
@verbatim
from chill import *
source('mm.c')
procedure('mm')
loop(0)
known('ambn > 0', 'an > 0', 'bm > 0')
distribute([0,1], 1)
unroll(1, 3, 4)
print_code()
@end verbatim
@end cartouche
@end smallformat
@tab @b{Original code}
@smallformat
@cartouche
@verbatim
void mm(float **A, float **B, float **C, 
     int ambn, int an, int bm) {
  int i, j, n;

  for(i = 0; i < an; i++)
    for(j = 0; j < bm; j++) {
      C[i][j] = 0.0f;
      for(n = 0; n < ambn; n++)
        C[i][j] += A[i][n] * B[n][j];
    }
}
@end verbatim
@end cartouche
@end smallformat
@end multitable

@multitable @columnfractions .50 .50
@b{Output on stdout}
@smallformat
@cartouche
@verbatim
for(t2 = 0; t2 <= an-1; t2++) {
  for(t4 = 0; t4 <= bm-1; t4++) {
    s0(t2,t4,0);
  }
}
for(t2 = 0; t2 <= an-1; t2++) {
  for(t4 = 0; t4 <= bm-1; t4++) {
    s2(t2,t4);
    for(t6 = 0; t6 <= -over1+ambn-1; 
        t6 += 4) {
      s1(t2,t4,t6);
      s4(t2,t4,t6);
    }
    for(t6 = max(0, ambn-over1); 
        t6 <= ambn-1; t6++) {
      s3(t2,t4,t6);
    }
  }
}
@end verbatim
@end cartouche
@end smallformat
@tab @b{Transformed code}
@smallformat
@cartouche
@verbatim
#define __rose_gt(x,y) ((x)>(y)?(x):(y))

void mm(float **A, float **B, float **C,
        int ambn, int an, int bm)
{
  int i, j, n, over1;
  over1 = 0;
  for (i = 0; i <= an - 1; i += 1) 
    for (j = 0; j <= bm - 1; j += 1) 
      C[i][j] = 0.0f;
  for (i = 0; i <= an - 1; i += 1) 
    for (j = 0; j <= bm - 1; j += 1) {
      over1 = ambn % 4;
      for (n = 0; n <= -over1 + ambn - 1; 
           n += 4) {
        C[i][j] += (A[i][n]*B[n][j]);
        C[i][j] += (A[i][n+1]*B[n+1][j]);
        C[i][j] += (A[i][n+2]*B[n+2][j]);
        C[i][j] += (A[i][n+3]*B[n+3][j]);
      }
      for (n = __rose_gt(0,ambn - over1); 
           n <= ambn - 1; n += 1) 
        C[i][j] += (A[i][n] * B[n][j]);
    }
}
@end verbatim
@end cartouche
@end smallformat
@end multitable

@c --------------------------------- Split -----------------------------
@page
@unnumberedsubsec Split
@deftypefn {Transform} @code{split} {} (int @var{stmt}, int @var{level}, int @var{condition})
The @code{split} transformation allows a loop to be split.
@b{Arguments}

@c Split
@c The split command has the form:
@c split (expr, number, cond)
@c The split command @dots{}
@c split          stmt#
@c                loop level to split
@c                expression
@c                  in which L<n> has special meaning of loop level n,
@c                  only one expression is allowed, i.e no logical and/or of
@c                  multiple formulas

@b{Conditions}
@end deftypefn

@c @include examples/split.texi

@c --------------------------------- Nonsingular -----------------------------
@page
@unnumberedsubsec Nonsingular
@c Nonsingular
@deftypefn {Transform} @code{nonsingular} {} (matrix @var{transform})
The @code{nonsingular} transformation @dots{}@refill

@b{Arguments}

@c The nonsingular command has the form:
@c nonsingular (matrix)
@c The nonsingular command @dots{}
@c nonsingular    [[vector],...,[vector]]
@c                  matrix parameter describes a unimodular or nonunimodular
@c                  transformation to be performed on the perfect loop nest,
@c                  the only requirement for the matrix is invertible. each
@c                  vector can be (n+1)-dimension where n is iteration space
@c                  dimension. in the case, the last entry in the vector is
@c                  interpreted as the constant shift factor.

@sp 2
@b{Conditions}
@end deftypefn

@c @include examples/nonsingular.texi


@c --------------------------------- Skew -----------------------------
@page
@unnumberedsubsec Skew
@c Skew
@deftypefn {Transform} @code{skew} {} (set @var{stmts}, int @var{level}, vector<int> @var{skew_amount})
The @code{skew} transformation @dots{}@refill

@b{Arguments}


@c The skew command has the form:
@c skew (vector, number, vector)
@c The skew command @dots{}
@c skew            [set of statement numbers]
@c                 loop level
@c                 [skewing amount vector]
@c                   assuming targeted loop level is 2 and skewing vector is
@c                   [1,1], then new loop at level 2 for statements in the first
@c                 parameter is mapped to L1+L2

@sp 2
@b{Conditions}
@end deftypefn
@multitable @columnfractions .50 .50 
@b{Python Script}
@smallformat
@cartouche
@verbatim
from chill import *
source('mm.c')
procedure('mm')
loop(0)
known('ambn > 0', 'an > 0', 'bm > 0')
skew([1],1,[4])
print_code()
@end verbatim
@end cartouche
@end smallformat
@tab @b{Original code}
@smallformat
@cartouche
@verbatim
void mm(float **A, float **B, float **C, 
     int ambn, int an, int bm) {
  int i, j, n;

  for(i = 0; i < an; i++)
    for(j = 0; j < bm; j++) {
      C[i][j] = 0.0f;
      for(n = 0; n < ambn; n++)
        C[i][j] += A[i][n] * B[n][j];
    }
}
@end verbatim
@end cartouche
@end smallformat
@end multitable

@multitable @columnfractions .50 .50
@b{Output on stdout}
@smallformat
@cartouche
@verbatim
for(t2 = 0; t2 <= 4*an-4; t2++) {
  for(t4 = 0; t4 <= bm-1; t4++) {
    if (an >= t2+1) {
      s0(t2,t4,0);
      if (intMod(t2,4) == 0) {
        s1(t2/4,t4,0);
      }
    }
    else {
      if (intMod(t2,4) == 0) {
        s1(t2/4,t4,0);
      }
    }
    if (intMod(t2,4) == 0) {
      for(t6 = 1; t6 <= ambn-1; t6++) {
        s1(t2/4,t4,t6);
      }
    }
  }
}
@end verbatim
@end cartouche
@end smallformat
@tab @b{Transformed code}
@smallformat
@cartouche
@verbatim
void mm(float **A, float **B, float **C,
        int ambn, int an, int bm)
{
  int i, j, n;
  for (i = 0; i <= 4 * an - 4; i += 1) 
    for (j = 0; j <= bm - 1; j += 1) {
      if (i + 1 <= an) {
        C[i][j] = 0.0f;
        if (i % 4 == 0) 
          C[i/4][j] += (A[i/4][0]*B[0][j]);
      } else if (i % 4 == 0) 
        C[i/4][j] += (A[i/4][0]*B[0][j]);
      if (i % 4 == 0) 
        for (n = 1; n <= ambn - 1; n += 1) 
          C[i/4][j] += (A[i/4][n]*B[n][j]);
    }
}
@end verbatim
@end cartouche
@end smallformat
@end multitable

@c --------------------------------- Scale -----------------------------
@page
@unnumberedsubsec Scale
@deftypefn {Transform} @code{scale} {} (set @var{stmts}, int @var{level}, vector<int> @var{scale_amount})
The @code{scale} transformation @dots{}@refill

@b{Arguments}

@c The scale command has the form:
@c scale (vector, number, expr)
@c The scale command @dots{}
@c scale           [set of statement numbers]
@c                 loop level
@c                 scale amount
@c                   shortcut to "skew([...],level,[0,..,0,amount])"

@b{Conditions}
@end deftypefn
@multitable @columnfractions .50 .50 
@b{Python Script}
@smallformat
@cartouche
@verbatim
from chill import *
source('mm.c')
procedure('mm')
loop(0)
known(['ambn > 0', 'an > 0', 'bm > 0'])
distribute([0,1],1)
scale([1],1,4)
scale([1],2,4)
print_code()
@end verbatim
@end cartouche
@end smallformat
@tab @b{Original code}
@smallformat
@cartouche
@verbatim
void mm(float **A, float **B, float **C, 
        int ambn, int an, int bm) {
  int i, j, n;
  for(i = 0; i < an; i++)
    for(j = 0; j < bm; j++) {
      C[i][j] = 0.0f;
      for(n = 0; n < ambn; n++)
        C[i][j] += A[i][n] * B[n][j];
    }
}
@end verbatim
@end cartouche
@end smallformat
@end multitable

@multitable @columnfractions .50 .50
@b{Output on stdout}
@smallformat
@cartouche
@verbatim
for(t2 = 0; t2 <= an-1; t2++) {
  for(t4 = 0; t4 <= bm-1; t4++) {
    s0(t2,t4,0);
  }
}
for(t2 = 0; t2 <= 4*an-4; t2 += 4) {
  for(t4 = 0; t4 <= 4*bm-4; t4 += 4) {
    for(t6 = 0; t6 <= ambn-1; t6++) {
      s1(t2/4,t4/4,t6);
    }
  }
}
@end verbatim
@end cartouche
@end smallformat
@tab @b{Transformed code}
@smallformat
@cartouche
@verbatim
void mm(float **A, float **B, float **C,
        int ambn, int an, int bm) {
  int i, j, n;
  for (i = 0; i <= an - 1; i += 1) 
    for (j = 0; j <= bm - 1; j += 1) 
      C[i][j] = 0.0f;
  for (i = 0; i <= 4 * an - 4; i += 4) 
    for (j = 0; j <= 4 * bm - 4; j += 4) 
      for (n = 0; n <= ambn - 1; n += 1) 
        C[i/4][j/4] += A[i/4][n]*B[n][j/4];
}
@end verbatim
@end cartouche
@end smallformat
@end multitable

@c --------------------------------- Reverse -----------------------------
@page
@unnumberedsubsec Reverse
@c Reverse
@deftypefn {Transform} @code{reverse} {} (set @var{stmts}, int @var{level})
The @code{reverse} transformation @dots{}@refill

@b{Arguments}

@c The reverse command has the form:
@c reverse (vector, number)
@c The reverse command @dots{}
@c reverse         [set of statement numbers]
@c                 loop level
@c                   shortcut to "scale([...],level,-1)"

@sp 2
@b{Conditions}
@end deftypefn
@multitable @columnfractions .50 .50 
@b{Python Script}
@smallformat
@cartouche
@verbatim
from chill import *
source('mm.c')
procedure('mm')
loop(0)
known(['ambn > 0', 'an > 0', 'bm > 0'])
distribute([0,1],1)
reverse([1],1)
reverse([1],2)
print_code()
@end verbatim
@end cartouche
@end smallformat
@tab @b{Original code}
@smallformat
@cartouche
@verbatim
void mm(float **A, float **B, float **C, 
        int ambn, int an, int bm) {
  int i, j, n;
  for(i = 0; i < an; i++)
    for(j = 0; j < bm; j++) {
      C[i][j] = 0.0f;
      for(n = 0; n < ambn; n++)
        C[i][j] += A[i][n] * B[n][j];
    }
}
@end verbatim
@end cartouche
@end smallformat
@end multitable

@multitable @columnfractions .50 .50
@b{Output on stdout}
@smallformat
@cartouche
@verbatim
for(t2 = 0; t2 <= an-1; t2++) {
  for(t4 = 0; t4 <= bm-1; t4++) {
    s0(t2,t4,0);
  }
}
for(t2 = -an+1; t2 <= 0; t2++) {
  for(t4 = -bm+1; t4 <= 0; t4++) {
    for(t6 = 0; t6 <= ambn-1; t6++) {
      s1(-t2,-t4,t6);
    }
  }
}
@end verbatim
@end cartouche
@end smallformat
@tab @b{Transformed code}
@smallformat
@cartouche
@verbatim
void mm(float **A, float **B, float **C,
        int ambn, int an, int bm) {
  int i, j, n;
  for (i = 0; i <= an - 1; i += 1) 
    for (j = 0; j <= bm - 1; j += 1) 
      C[i][j] = 0.0f;
  for (i = -an + 1; i <= 0; i += 1) 
    for (j = -bm + 1; j <= 0; j += 1) 
      for (n = 0; n <= ambn - 1; n += 1) 
        C[-i][-j] += (A[-i][n] * B[n][-j]);
}
@end verbatim
@end cartouche
@end smallformat
@end multitable

@c --------------------------------- Shift -----------------------------
@page
@unnumberedsubsec Shift
@deftypefn {Transform} @code{shift} {} (set @var{stmts}, int @var{shift_amount})
The shift command @dots{}
@b{Arguments}

@c shift (vector, number, expr)
@c shift           [set of statement numbers]
@c                 loop level
@c                 shift amount
@c                   assuming targeted loop level is 2 and shift amount is
@c                   1, then the new loop at level 2 for statements in the first
@c                   parameter is mapped to L2+1, i.e. shifted right by 1

@b{Conditions}
@end deftypefn
@multitable @columnfractions .50 .50 
@b{Python Script}
@smallformat
@cartouche
@verbatim
from chill import *
source('mm.c')
procedure('mm')
loop(0)
known(['ambn > 0', 'an > 0', 'bm > 0'])
shift([1],1,4)
print_code()
@end verbatim
@end cartouche
@end smallformat
@tab @b{Original code}
@smallformat
@cartouche
@verbatim
void mm(float **A, float **B, float **C, 
        int ambn, int an, int bm) {
  int i, j, n;

  for(i = 0; i < an; i++)
    for(j = 0; j < bm; j++) {
      C[i][j] = 0.0f;
      for(n = 0; n < ambn; n++)
        C[i][j] += A[i][n] * B[n][j];
    }
}
@end verbatim
@end cartouche
@end smallformat
@end multitable

@multitable @columnfractions .50 .50
@b{Output on stdout}
@smallformat
@cartouche
@verbatim
for(t2 = 0; t2 <= an+3; t2++) {
  for(t4 = 0; t4 <= bm-1; t4++) {
    if (an >= t2+1) {
      s0(t2,t4,0);
      if (t2 >= 4) {
        s1(t2-4,t4,0);
      }
      if (t2 >= 4) {
        for(t6 = 1; t6 <= ambn-1; t6++) {
          s1(t2-4,t4,t6);
        }
      }
    }
    else {
      if (t2 >= 4) {
        for(t6 = 0; t6 <= ambn-1; t6++) {
          s1(t2-4,t4,t6);
        }
      }
    }
  }
}
@end verbatim
@end cartouche
@end smallformat
@tab @b{Transformed code}
@smallformat
@cartouche
@verbatim
void mm(float **A, float **B, float **C,
        int ambn, int an, int bm) {
  int i, j, n;
  for (i = 0; i <= an + 3; i += 1) 
    for (j = 0; j <= bm-1; j += 1) 
      if (i + 1 <= an) {
        C[i][j] = 0.0f;
        if (4 <= i) 
          C[i-4][j] += A[i-4][0]*B[0][j];
        if (4 <= i) 
          for (n = 1; n <= ambn-1; n += 1) 
            C[i-4][j] += A[i-4][n]*B[n][j];
      }
      else if (4 <= i) 
        for (n = 0; n <= ambn-1; n += 1) 
          C[i-4][j] += A[i-4][n]*B[n][j];
}
@end verbatim
@end cartouche
@end smallformat
@end multitable

@c --------------------------------- ShiftTo -----------------------------
@page
@unnumberedsubsec Shift_to
@c ShiftTo
@deftypefn {Transform} @code{shift_to} {} (set @var{stmts}, int @var{absolute_position})
The @code{shift} transformation @dots{}
@b{Arguments}

@c shift_to        stmt#
@c                 loop level
@c                 absolute position
@c                   shift the loop starting point to this position

@b{Conditions}
@end deftypefn
@multitable @columnfractions .50 .50 
@b{Python Script}
@smallformat
@cartouche
@verbatim
from chill import *
source('mm.c')
procedure('mm')
loop(0)
known(['ambn > 0', 'an > 0', 'bm > 0'])
shift_to(1,1,4)
print_code()
@end verbatim
@end cartouche
@end smallformat
@tab @b{Original code}
@smallformat
@cartouche
@verbatim
void mm(float **A, float **B, float **C, 
        int ambn, int an, int bm) {
  int i, j, n;
  for(i = 0; i < an; i++)
    for(j = 0; j < bm; j++) {
      C[i][j] = 0.0f;
      for(n = 0; n < ambn; n++)
        C[i][j] += A[i][n] * B[n][j];
    }
}
@end verbatim
@end cartouche
@end smallformat
@end multitable

@multitable @columnfractions .50 .50
@b{Output on stdout}
@smallformat
@cartouche
@verbatim
for(t2 = 4; t2 <= an+3; t2++) {
  for(t4 = 0; t4 <= bm-1; t4++) {
    s0(t2-4,t4,0);
    s1(t2-4,t4,0);
    for(t6 = 1; t6 <= ambn-1; t6++) {
      s1(t2-4,t4,t6);
    }
  }
}
@end verbatim
@end cartouche
@end smallformat
@tab @b{Transformed code}
@smallformat
@cartouche
@verbatim
void mm(float **A, float **B, float **C,
        int ambn, int an, int bm) {
  int i, j, n;
  for (i = 4; i <= an + 3; i += 1) 
    for (j = 0; j <= bm-1; j += 1) {
      C[i-4][j] = 0.0f;
      C[i-4][j] += A[i-4][0]*B[0][j];
      for (n = 1; n <= ambn-1; n += 1) 
        C[i-4][j] += A[i-4][n]*B[n][j];
    }
}
@end verbatim
@end cartouche
@end smallformat
@end multitable

@c --------------------------------- Peel -----------------------------
@page
@unnumberedsubsec Peel
@c Peel
@deftypefn {Transform} @code{peel} {} (int @var{stmt}, int @var{loop}, int @var{peel_amount} = 1)
The @code{peel} transformation @dots{}@refill
@c The peel command has two forms:
@c peel (number, number, expr)
@c peel (number, number)
@c The peel command @dots{}
@c peel            stmt#
@c                 loop level
@c                 peel amount (default to 1)
@c                   if positive, peel the specified number of iterations from the
@c                 start of the loop; if negative, peel from the end
@end deftypefn
@multitable @columnfractions .50 .50 
@b{Python Script}
@smallformat
@cartouche
@verbatim
from chill import *
source('mm.c')
procedure('mm')
loop(0)
known(['ambn > 4', 'an > 0', 'bm > 0'])
peel(1,3,4)
print_code()
@end verbatim
@end cartouche
@end smallformat
@tab @b{Original code}
@smallformat
@cartouche
@verbatim
void mm(float **A, float **B, float **C, 
        int ambn, int an, int bm) {
  int i, j, n;
  for(i = 0; i < an; i++)
    for(j = 0; j < bm; j++) {
      C[i][j] = 0.0f;
      for(n = 0; n < ambn; n++)
        C[i][j] += A[i][n] * B[n][j];
    }
}
@end verbatim
@end cartouche
@end smallformat
@end multitable

@multitable @columnfractions .50 .50
@b{Output on stdout}
@smallformat
@cartouche
@verbatim
for(t2 = 0; t2 <= an-1; t2++) {
  for(t4 = 0; t4 <= bm-1; t4++) {
    s2(t2,t4,0);
    s3(t2,t4,0);
    s4(t2,t4,1);
    s5(t2,t4,2);
    s6(t2,t4,3);
    for(t6 = 4; t6 <= ambn-1; t6++) {
      s1(t2,t4,t6);
    }
  }
}
@end verbatim
@end cartouche
@end smallformat
@tab @b{Transformed code}
@smallformat
@cartouche
@verbatim
void mm(float **A, float **B, float **C,
        int ambn, int an, int bm) {
  int i, j, n;
  for (i = 0; i <= an - 1; i += 1) 
    for (j = 0; j <= bm - 1; j += 1) {
      C[i][j] = 0.0f;
      C[i][j] += (A[i][0] * B[0][j]);
      C[i][j] += (A[i][1] * B[1][j]);
      C[i][j] += (A[i][2] * B[2][j]);
      C[i][j] += (A[i][3] * B[3][j]);
      for (n = 4; n <= ambn - 1; n += 1) 
        C[i][j] += (A[i][n] * B[n][j]);
    }
}
@end verbatim
@end cartouche
@end smallformat
@end multitable

@c --------------------------------- Fuse -----------------------------
@page
@unnumberedsubsec Fuse
@deftypefn {Transform} @code{fuse} {} (set @var{stmts}, int @var{loop_level})
The @code{fuse} transformation @dots{}@refill

@b{Arguments}

@c The fuse command has the form:
@c fuse (vector, number)
@c The fuse command @dots{}
@c fuse            [set of statement numbers]
@c                 loop level

@b{Conditions}
@end deftypefn

@multitable @columnfractions .50 .50 
@b{Python Script}
@smallformat
@cartouche
@verbatim
from chill import *
source('mm.c')
procedure('mm')
loop(0)
known(['ambn > 0', 'an > 0', 'bm > 0'])
fuse([0,1], 1)
print_code()
@end verbatim
@end cartouche
@end smallformat
@tab @b{Original code}
@smallformat
@cartouche
@verbatim
void mm(float **A, float **B, float **C, 
        int ambn, int an, int bm) {
  int i, j, n;
  for(i = 0; i < an; i++)
    for(j = 0; j < bm; j++) {
      C[i][j] = 0.0f;
      for(n = 0; n < ambn; n++)
        C[i][j] += A[i][n] * B[n][j];
    }
}
@end verbatim
@end cartouche
@end smallformat
@end multitable

@multitable @columnfractions .50 .50
@b{Output on stdout}
@smallformat
@cartouche
@verbatim
for(t2 = 0; t2 <= an-1; t2++) {
  for(t4 = 0; t4 <= bm-1; t4++) {
    s0(t2,t4,0);
  }
}
for(t2 = 0; t2 <= an-1; t2++) {
  for(t4 = 0; t4 <= bm-1; t4++) {
    for(t6 = 0; t6 <= ambn-1; t6++) {
      s1(t2,t4,t6);
    }
  }
}


@end verbatim
@end cartouche
@end smallformat
@tab @b{Transformed code}
@smallformat
@cartouche
@verbatim
void mm(float **A, float **B, float **C,
        int ambn, int an, int bm) {
  int i, j, n;
  for (i = 0; i <= an - 1; i += 1) 
    for (j = 0; j <= bm - 1; j += 1) 
      C[i][j] = 0.0f;
  for (i = 0; i <= an - 1; i += 1) 
    for (j = 0; j <= bm - 1; j += 1) 
      for (n = 0; n <= ambn - 1; n += 1) 
        C[i][j] += (A[i][n] * B[n][j]);
}
@end verbatim
@end cartouche
@end smallformat
@end multitable

@c --------------------------------- Distribute -----------------------------
@page
@unnumberedsubsec Distribute
@deftypefn {Transform} @code{distribute} {} (set @var{stmts}, int @var{loop_level})
The @code{distribute} transformation @dots{}@refill

@b{Arguments}

@c The distribute command has the form:
@c distribute (vector, number)
@c The distribute command @dots{}
@c distribute      [set of statement numbers]
@c                 loop level

@b{Conditions}
@end deftypefn
@multitable @columnfractions .50 .50 
@b{Python Script}
@smallformat
@cartouche
@verbatim
from chill import *
source('mm.c')
procedure('mm')
loop(0)
known(['ambn > 0', 'an > 0', 'bm > 0'])
distribute([0,1], 1)
print_code()
@end verbatim
@end cartouche
@end smallformat
@tab @b{Original code}
@smallformat
@cartouche
@verbatim
void mm(float **A, float **B, float **C, 
        int ambn, int an, int bm) {
  int i, j, n;
  for(i = 0; i < an; i++)
    for(j = 0; j < bm; j++) {
      C[i][j] = 0.0f;
      for(n = 0; n < ambn; n++)
        C[i][j] += A[i][n] * B[n][j];
    }
}
@end verbatim
@end cartouche
@end smallformat
@end multitable

@multitable @columnfractions .50 .50
@b{Output on stdout}
@smallformat
@cartouche
@verbatim
for(t2 = 0; t2 <= an-1; t2++) {
  for(t4 = 0; t4 <= bm-1; t4++) {
    s0(t2,t4,0);
  }
}
for(t2 = 0; t2 <= an-1; t2++) {
  for(t4 = 0; t4 <= bm-1; t4++) {
    for(t6 = 0; t6 <= ambn-1; t6++) {
      s1(t2,t4,t6);
    }
  }
}
@end verbatim
@end cartouche
@end smallformat
@tab @b{Transformed code}
@smallformat
@cartouche
@verbatim
void mm(float **A, float **B, float **C, 
        int ambn, int an, int bm) {
  int i, j, n;
  for (i = 0; i <= an - 1; i += 1) 
    for (j = 0; j <= bm - 1; j += 1) 
      C[i][j] = 0.0f;
  for (i = 0; i <= an - 1; i += 1) 
    for (j = 0; j <= bm - 1; j += 1) 
      for (n = 0; n <= ambn - 1; n += 1) 
        C[i][j] += (A[i][n] * B[n][j]);
}
@end verbatim
@end cartouche
@end smallformat
@end multitable

@page

@c Data operations
@c Prefetch
@c The prefetch command has the form:
@c prefetch (number, number, string, expr)
@c The prefetch command @dots{}
@c Datacopy
@c The datacopy command has eight forms:
@c datacopy (matrix, number)
@c datacopy (matrix, number, trueorfalse)
@c datacopy (matrix, number, trueorfalse, expr)
@c datacopy (matrix, number, trueorfalse, expr, expr)
@c datacopy (matrix, number, trueorfalse, expr, expr, expr)
@c datacopy (expr, number, variable)
@c datacopy (expr, number, variable, trueorfalse)
@c datacopy (expr, number, variable, trueorfalse, expr)
@c datacopy (expr, number, variable, trueorfalse, expr, expr)
@c datacopy (expr, number, variable, trueorfalse, expr, expr, expr)
@c The datacopy command @dots{}
@c datacopy       stmt#
@c                loop level
@c                  inside which data footprint is copied and put right before
@c                  this loop
@c                array name
@c                  all array accesses in the subloop with this array name
@c                true|false (default = false)
@c                   whether extra data copy is allowed to simplify read copy loop
@c                fastest changing dimension in the new array layout
@c                  = -1 (default) means no change in array layout
@c                  = d  means contiguous array elements in the memory at
@c                       d-th dimension
@c                stride padding
@c                  = 0 means keep the original data layout in all dimensions
@c                  = 1 (default) means compressed array layout
@c                  = d (d>=1) means accessing the fastest-changing-dimension
@c                      in stride d, while other array dimensions are compressed
@c                alignment padding (default = 4)
@c                  = 1 means no alignment necessary 
@c                  = d (d>1) means that the size of the fastest changing
@c                      dimension is multiples of d
@c                  = d (d<-1) means the size of the fastest changing
@c                      dimension is coprime with |d|
@c datacopy       [[stmt#,ref#1,ref#2,...],[...],...]
@c                  array numbering follows accessing order, e.g.
@c                  C[<2>]=C[<0>]*B[<1>]
@c                level level
@c                true|false
@c                fastest changing dimension in the new array layout
@c                stride padding
@c                alignment padding
@c                  ...see above...
@c Datacopy_Privatized
@c The datacopy privatized command has two forms:
@c datacopy_privatized (matrix, number, vector, trueorfalse, expr, expr, expr)
@c datacopy_privatized (expr, number, variable, vector, trueorfalse, expr, expr, expr)
@c The datacopy privatized command @dots{}
@c datacopy_privatized
@c                stmt#
@c                loop level
@c                array name
@c                [privatized loop levels]
@c                   array footprint by assuming these loop levels fixed,
@c                   the output code is only correct in parallel mode.
@c                true|false
@c                fastest changing dimension
@c                stride padding
@c                alignment padding
@c                  ...see above...
@c datacopy_privatized
@c                [[stmt#,ref#1,ref#2,...],[...],...]
@c                level level
@c                [privatized loop levels]
@c                true|false
@c                fastest changing dimension in the new array layout
@c                stride padding
@c                alignment padding
@c                  ...see above...
@c CUDA-CHiLL 
@c Cudaize
@c The cudaize command has the form:
@c cudaize (...)
@c The cudaize command @dots{}
@c cudaize         kernel name
@c                 stmt num
@c                 loop level
@c                 grid x size
@c                 grid y size
@c                 array size(input array size, only needed when not statically defined)
@c                 memory model (global)

@c                 Cudaize call means there will be a cudaize step in the code-gen. 
@c                 The last parameter specifies the memory model for the
@c                 arrays. "textured" could be explored in the future.

@c                 If using 1D arrays, the dimention of the referenced arrays is specified
@c                 with the N parameter for used with malloc/memcpy in the generated
@c                 scaffolding code.
@c Cudathread
@c The cudathread command has the form:
@c cudathread (...)
@c The cudathread command @dots{}
@c cudathread      [vector] of pairs of stmt numbers nad loop levels to indicate a loop
@c                 thread x size
@c                 thread y size (optionally)
@c                 thread z size (optionally)

@c                 The CudaThread command indicates that some loop levels will be reduced
@c                 as thread.{x,y,z} in the kernel. It can specify one, two or three
@c                 dimensions by providing the loop level and related dimention.

@c                 The first parameter is the location of the loop. Its in array form to
@c                 allow for addressing arbitrarily complex positions in a loop tree. The
@c                 addressing starts from the inner block of the loops that are reduced by
@c                 the cudaize command. For example [0,1] is stmt 0, loop 1. [1,1,0,1] is
@c                 stmt 1, loop 1, then inside that loop stmt 0, loop 1.

@c                 A "SYNC" last parameter means a __syncthreads() is
@c                 inserted after the respective code generated in the kernel.

@c                 A invariant that raises an exception is that all cudathread
@c                 calls must use the same dimentions between calls. i.e. threads can not
@c                 be 16x16 in one call and 16x4 in another.

@c @node Index
@unnumbered Index
@printindex cp

